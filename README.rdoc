= AmountField

Allows amount value in german or us format like 1.234,56 or 1,234.56.

Only tested for Rails 2.3. It may works with older versions but I haven't tested it.
Drop me a line if you encounter problems.

== Installation

As Gem:

  $ gem sources -a http://gems.github.com (you only have to do this once)
  $ sudo gem install thomasbaustert-amount_field

As plugin:

  $ script/plugin install git://github.com/thomasbaustert/amount_field.git

== Example

First use the helper <tt>amount_field</tt> or <tt>amount_field_tag</tt> instead of
the <tt>text_field</tt> helper:

  <% form_for(@product) do |f| %>
    <%= f.amount_field :price %>
     ...    
  <% end %>

  <% form_tag(:action => "create", {}) do -%> 
    <%= amount_field_tag :product, :price %>
  ...  

Second use the validation macro <tt>validates_amount_format_of</tt> in your model:

  class Product < ActiveRecord::Base
    validates_amount_format_of :price
    validates_numericality_of :price
    validates_presence_of :price
    ...
  end
  
Note! Make sure you always call <tt>validates_amount_format_of</tt> *before* every 
other validation macro for the same attribute (e.g. before <tt>validates_numericality_of</tt>
and <tt>validates_presence_of</tt> for <tt>price</tt>).

== Configuration

Definition:
  
  Delimiter = thousand separator (e.g. '.' in 1.234.567)
  Separator = separator of value and decimal places (e.g. ',' in 12,56)
  Precision = number of decimal places

The format configuration for all <tt>validates_amount_format_of</tt> is a hash with 
the I18n values of Rails by default:

  { :precision => I18n.t('number.precision.format.precision'), 
    :delimiter => I18n.t('number.precision.format.delimiter'), 
    :separator => I18n.t('number.precision.format.separator') }

While Rails provides the us format by default, the values for the german format (de) 
are included in this gem. If you want the german format to be active, set the locale:

  I18n.locale = :de

If you don't want to depend on I18n, you can define your own default configuration via:

  # environment.rb
  AmountField::ActiveRecord::Validations.configuration = 
    { :precision => 1, :delimiter => ',', :separator => '.' }

And then might switch the configuration at runtime via a before filter:

  def set_amount_field_format
    if MyI18nLib.locale == :en
      AmountField::ActiveRecord::Validations.configuration = {...en...}
    else
      AmountField::ActiveRecord::Validations.configuration = {...de...}
    end  
  end

An explicitly defined format will overwrite the default configuration for that attribute:
  
  validates_amount_format_of :price, :separator => '.', :delimiter => ','
  # VALID: "1,234.56" (1234.56) INVALID: "1.234,56"

Integer values with a thousand separator can be defined as follows:
  
  validates_amount_format_of :price, :precision => 0, :separator => nil
  # VALID: "1.234" (1234.0) INVALID: "1.234,56"

A value with no thousand separator and not decimal places can be defined as follows:

  validates_amount_format_of :price, :delimiter => nil 
  # VALID: "1234,56" (1234.56) INVALID: "1.234,56"

Explicit precision can be defined too:
  
  validates_amount_format_of :price, :precision => 1
  # VALID: "1.234,5" (1234.5) INVALID: "1.234,56"

Standard Rails options like <tt>:allow_blank</tt>, or <tt>:allow_nil</tt> are supported:

  validates_amount_format_of :price, :allow_blank => true
  # VALID: ""

More configuration see section "Details".

== Error Messages

By default the german and english messages are taken from the file (a simple I18n backend)
<tt>amount_field/locale/(en|de).yml</tt> through the key 
<tt>activerecord.errors.messages.invalid_amount_format</tt>.

You can define your own by adding your Yaml file to the load path like:

  # environment.rb
  I18n.load_path << "#{RAILS_ROOT}/locale/en.yml"

  # "#{RAILS_ROOT}/locale/en.yml"
  de:
    activerecord:
      errors:
        messages:
          invalid_amount_format: "bla ... '{{value}}' blub ...  ({{format_example}})"
    
The placeholder <tt>{{value}}</tt> is substituted with the given value (e.g. "1.x") and 
<tt>{{format_example}}</tt> with a valid example of the currently accepted format (e.g. 'd.ddd,dd').

== How does it work?

Basically the helper <tt>amount_field</tt> defines a input field like so:

  <input name="product[amount_field_price]" class=" amount_field"...
  
The validation macro <tt>validates_amount_format_of</tt> defines a special setter method
<tt>amount_field_price=(value)</tt> that accept the value. After successfully format 
validation the original parameter is converted to a ruby value (e.g. "1.234,56" to 1234.56)
and assigned to the original attribute <tt>price</tt>. Following validation macros work on
the the converted value. That's why it is currently important to call
<tt>validates_amount_format_of</tt> before every other macro.
  
The <tt>amount_field</tt> helper formats the value with <tt>number_with_precision</tt> by
default. You can explicitly set the value too:
    
    amount_field(:price, :value => ...)

== More Configuration
  
By default the input field contains the CSS class <tt>amount_field</tt> so you can define
a CSS layout for every amount field like:

  input.amount_field {
    text-align:right;
  }
  
The method prefix and the CSS class can be changed as follows:

  AmountField::Configuration.prefix = "my_prefix"
  AmountField::Configuration.css_class = "my_class"

That  will create the html:

  <input name="product[my_prefix_price]" class=" my_class"...

and the appropriate method <tt>my_prefix_price=(value)</tt>.

== Running Tests

You need a database <tt>gem_amount_field_test</tt> to run all tests.
See test_helper.rb for details.

== Credits

* Michael Schiller (for feedback and tipps)
 
== Contact

For comments and question feel free to contact me: business@thomasbaustert.de


Copyright (c) 2009 [Thomas Baustert], released under the MIT license
